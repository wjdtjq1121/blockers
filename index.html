<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>ë¸”ë¡œì»¤ìŠ¤ - Blokus Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 1400px;
            width: 100%;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .player-info {
            padding: 15px 25px;
            border-radius: 10px;
            min-width: 150px;
            text-align: center;
            transition: all 0.3s;
        }

        .player-info.active {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .player-info.blue { background: #2196F3; color: white; }
        .player-info.yellow { background: #FFC107; color: #333; }
        .player-info.red { background: #F44336; color: white; }
        .player-info.green { background: #4CAF50; color: white; }

        .player-info .name {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .player-info .pieces-left {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .game-main {
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: flex-start;
        }

        .board-container {
            flex-shrink: 0;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(20, 25px);
            grid-template-rows: repeat(20, 25px);
            gap: 1px;
            background: #333;
            border: 3px solid #333;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .cell {
            background: white;
            width: 25px;
            height: 25px;
            position: relative;
        }

        .cell.corner {
            background: #f0f0f0;
        }

        .cell.start-corner {
            background: #2196F3 !important;
            opacity: 0.5;
            position: relative;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .cell.start-corner::after {
            content: 'â˜…';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: white;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        .cell.filled {
            border: 1px solid rgba(0,0,0,0.1);
        }

        .cell.filled.blue { background: #2196F3; }
        .cell.filled.yellow { background: #FFC107; }
        .cell.filled.red { background: #F44336; }
        .cell.filled.green { background: #4CAF50; }

        .cell.preview {
            opacity: 0.7;
            border: 2px solid rgba(0, 255, 0, 0.8);
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        .cell.invalid-preview {
            background: rgba(255, 0, 0, 0.5) !important;
            border: 2px solid rgba(255, 0, 0, 0.8) !important;
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
        }

        .pieces-container {
            flex: 1;
            max-width: 400px;
        }

        .pieces-container h2 {
            color: #333;
            margin-bottom: 15px;
        }

        .pieces-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            max-height: 600px;
            overflow-y: auto;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .piece {
            background: white;
            border: 2px solid #ddd;
            border-radius: 5px;
            padding: 5px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .piece:hover:not(.used) {
            transform: scale(1.05);
            border-color: #666;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }

        .piece.selected {
            border-color: #333;
            border-width: 3px;
            background: #f0f0f0;
        }

        .piece.used {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .piece-shape {
            display: grid;
            gap: 1px;
        }

        .piece-cell {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .piece-cell.filled.blue { background: #2196F3; }
        .piece-cell.filled.yellow { background: #FFC107; }
        .piece-cell.filled.red { background: #F44336; }
        .piece-cell.filled.green { background: #4CAF50; }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: #2196F3;
            color: white;
        }

        .btn-secondary {
            background: #666;
            color: white;
        }

        .btn-success {
            background: #4CAF50;
            color: white;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .game-over.show {
            display: flex;
        }

        .game-over-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
        }

        .game-over-content h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #333;
        }

        .final-scores {
            margin: 20px 0;
        }

        .score-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            font-size: 1.2em;
        }

        .message {
            margin: 15px 0;
            padding: 10px;
            border-radius: 5px;
            background: #f0f0f0;
            color: #333;
            font-weight: bold;
        }

        .debug-info {
            margin: 10px 0;
            padding: 10px;
            background: #333;
            color: #0f0;
            font-family: monospace;
            font-size: 0.9em;
            border-radius: 5px;
            max-height: 100px;
            overflow-y: auto;
        }

        .cell {
            cursor: pointer;
        }

        .cell:hover {
            outline: 2px solid #ff0;
        }

        /* ëª¨ë°”ì¼ ìµœì í™” */
        @media screen and (max-width: 768px) {
            .desktop-only {
                display: none !important;
            }

            body {
                padding: 10px;
                align-items: flex-start;
            }

            .game-container {
                padding: 15px;
                border-radius: 10px;
            }

            .game-header h1 {
                font-size: 1.8em;
                margin-bottom: 5px;
            }

            .game-info {
                gap: 5px;
                margin-bottom: 10px;
            }

            .player-info {
                padding: 8px 12px;
                min-width: 80px;
                font-size: 0.85em;
            }

            .player-info .name {
                font-size: 0.95em;
                margin-bottom: 2px;
            }

            .player-info .pieces-left {
                font-size: 0.75em;
            }

            .message {
                margin: 10px 0;
                padding: 8px;
                font-size: 0.9em;
            }

            .debug-info {
                display: none; /* ëª¨ë°”ì¼ì—ì„œëŠ” ë””ë²„ê·¸ ì •ë³´ ìˆ¨ê¹€ */
            }

            .game-main {
                flex-direction: column;
                gap: 15px;
                align-items: center;
            }

            .board {
                grid-template-columns: repeat(20, 18px);
                grid-template-rows: repeat(20, 18px);
                gap: 0.5px;
                border: 2px solid #333;
            }

            .cell {
                width: 18px;
                height: 18px;
            }

            .cell.start-corner::after {
                font-size: 14px;
            }

            .pieces-container {
                max-width: 100%;
                width: 100%;
            }

            .pieces-container h2 {
                font-size: 1.2em;
                margin-bottom: 10px;
            }

            .pieces-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 8px;
                max-height: 400px;
                padding: 8px;
            }

            .piece {
                padding: 4px;
            }

            .piece-cell {
                width: 10px;
                height: 10px;
            }

            .controls {
                margin-top: 10px;
                gap: 8px;
                flex-wrap: wrap;
            }

            .btn {
                padding: 12px 16px;
                font-size: 0.95em;
                flex: 1;
                min-width: 100px;
            }

            .game-over-content {
                padding: 25px;
                margin: 10px;
                max-width: 90%;
            }

            .game-over-content h2 {
                font-size: 1.8em;
            }

            .score-item {
                font-size: 1em;
                padding: 8px;
            }

            /* í„°ì¹˜ ì˜ì—­ í™•ëŒ€ */
            .cell {
                cursor: pointer;
                -webkit-tap-highlight-color: rgba(255, 255, 0, 0.3);
            }

            .piece {
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
            }

            .btn {
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
            }
        }

        /* ë§¤ìš° ì‘ì€ í™”ë©´ (360px ì´í•˜) */
        @media screen and (max-width: 400px) {
            .game-header h1 {
                font-size: 1.5em;
            }

            .board {
                grid-template-columns: repeat(20, 15px);
                grid-template-rows: repeat(20, 15px);
            }

            .cell {
                width: 15px;
                height: 15px;
            }

            .cell.start-corner::after {
                font-size: 11px;
            }

            .pieces-grid {
                grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
                gap: 6px;
            }

            .piece-cell {
                width: 8px;
                height: 8px;
            }

            .btn {
                padding: 10px 12px;
                font-size: 0.85em;
                min-width: 80px;
            }

            .player-info {
                padding: 6px 10px;
                min-width: 70px;
                font-size: 0.8em;
            }
        }

        /* ê°€ë¡œ ëª¨ë“œ ëª¨ë°”ì¼ */
        @media screen and (max-width: 900px) and (orientation: landscape) {
            .game-main {
                flex-direction: row;
            }

            .board {
                grid-template-columns: repeat(20, 16px);
                grid-template-rows: repeat(20, 16px);
            }

            .cell {
                width: 16px;
                height: 16px;
            }

            .pieces-container {
                max-width: 300px;
            }

            .pieces-grid {
                max-height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>ğŸ® ë¸”ë¡œì»¤ìŠ¤ (Blokus)</h1>
        </div>

        <div class="game-info" id="playersInfo">
            <!-- Players info will be inserted here -->
        </div>

        <div class="message" id="messageBox">ê²Œì„ ì‹œì‘! íŒŒë‘ í”Œë ˆì´ì–´ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤.</div>
        <div class="debug-info" id="debugInfo">ë””ë²„ê·¸: ëŒ€ê¸° ì¤‘...</div>

        <div class="game-main">
            <div class="board-container">
                <div class="board" id="gameBoard">
                    <!-- Board cells will be inserted here -->
                </div>
            </div>

            <div class="pieces-container" id="piecesContainer">
                <h2>ë‚´ ì¡°ê°ë“¤</h2>
                <div class="controls">
                    <button class="btn btn-primary" onclick="rotatePiece()">ğŸ”„ íšŒì „</button>
                    <button class="btn btn-secondary" onclick="flipPiece()">â†”ï¸ ë’¤ì§‘ê¸°</button>
                    <button class="btn btn-secondary" onclick="deselectPiece()">âŒ ì„ íƒ ì·¨ì†Œ</button>
                </div>
                <div class="pieces-grid" id="piecesGrid">
                    <!-- Pieces will be inserted here -->
                </div>
            </div>
        </div>

        <div class="controls" style="margin-top: 20px;">
            <button class="btn btn-success" onclick="skipTurn()">â­ï¸ í„´ ë„˜ê¸°ê¸°</button>
            <button class="btn btn-secondary" onclick="resetGame()">ğŸ”„ ìƒˆ ê²Œì„</button>
            <button class="btn btn-primary desktop-only" onclick="testClick()">ğŸ§ª ìƒíƒœ í™•ì¸</button>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <div class="game-over-content">
            <h2>ğŸ‰ ê²Œì„ ì¢…ë£Œ!</h2>
            <div class="final-scores" id="finalScores">
                <!-- Final scores will be inserted here -->
            </div>
            <button class="btn btn-success" onclick="resetGame()">ìƒˆ ê²Œì„ ì‹œì‘</button>
        </div>
    </div>

    <script>
        // ë¸”ë¡œì»¤ìŠ¤ ì¡°ê° ì •ì˜ (21ê°œì˜ í´ë¦¬ì˜¤ë¯¸ë…¸)
        const PIECE_SHAPES = [
            [[1]], // 1ì¹¸
            [[1,1]], // 2ì¹¸
            [[1,1,1]], // 3ì¹¸ - ì§ì„ 
            [[1,1],[1,0]], // 3ì¹¸ - L
            [[1,1,1,1]], // 4ì¹¸ - ì§ì„ 
            [[1,1,1],[1,0,0]], // 4ì¹¸ - L
            [[1,1,1],[0,1,0]], // 4ì¹¸ - T
            [[1,1,0],[0,1,1]], // 4ì¹¸ - Z
            [[1,1],[1,1]], // 4ì¹¸ - ì •ì‚¬ê°í˜•
            [[1,1,1,1,1]], // 5ì¹¸ - ì§ì„ 
            [[1,1,1,1],[1,0,0,0]], // 5ì¹¸ - L
            [[1,1,1,1],[0,0,0,1]], // 5ì¹¸ - L ëŒ€ì¹­
            [[1,1,1],[1,1,0]], // 5ì¹¸ - P
            [[1,1,1],[0,1,1]], // 5ì¹¸ - P ëŒ€ì¹­
            [[1,1,1],[0,1,0],[0,1,0]], // 5ì¹¸ - T
            [[1,1,0],[0,1,0],[0,1,1]], // 5ì¹¸ - Z
            [[0,1,0],[1,1,1],[0,1,0]], // 5ì¹¸ - +
            [[1,1,1],[1,0,1]], // 5ì¹¸ - U
            [[1,1,0],[0,1,1],[0,0,1]], // 5ì¹¸ - W
            [[0,1,1],[1,1,0],[1,0,0]], // 5ì¹¸ - N
            [[1,0,0],[1,1,1],[0,0,1]], // 5ì¹¸ - Y
        ];

        // ê²Œì„ ìƒíƒœ
        const game = {
            board: Array(20).fill(null).map(() => Array(20).fill(null)),
            players: [
                { name: 'í”Œë ˆì´ì–´', color: 'blue', pieces: [], isAI: false, canPlay: true, cornerX: 0, cornerY: 0 },
                { name: 'AI 1', color: 'yellow', pieces: [], isAI: true, canPlay: true, cornerX: 19, cornerY: 0 },
                { name: 'AI 2', color: 'red', pieces: [], isAI: true, canPlay: true, cornerX: 19, cornerY: 19 },
                { name: 'AI 3', color: 'green', pieces: [], isAI: true, canPlay: true, cornerX: 0, cornerY: 19 }
            ],
            currentPlayerIndex: 0,
            selectedPieceIndex: null,
            gameStarted: false,
            passCount: 0
        };

        // ì¡°ê° ì´ˆê¸°í™”
        function initializePieces() {
            game.players.forEach(player => {
                player.pieces = PIECE_SHAPES.map(shape => ({
                    shape: shape,
                    used: false,
                    rotation: 0,
                    flipped: false
                }));
            });
        }

        // ì¡°ê° íšŒì „
        function rotateShape(shape) {
            const rows = shape.length;
            const cols = shape[0].length;
            const rotated = Array(cols).fill(null).map(() => Array(rows).fill(0));

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    rotated[c][rows - 1 - r] = shape[r][c];
                }
            }
            return rotated;
        }

        // ì¡°ê° ë’¤ì§‘ê¸°
        function flipShape(shape) {
            return shape.map(row => [...row].reverse());
        }

        // ì¡°ê°ì˜ í˜„ì¬ í˜•íƒœ ê°€ì ¸ì˜¤ê¸°
        function getCurrentShape(piece) {
            let shape = piece.shape;

            // ë’¤ì§‘ê¸°
            if (piece.flipped) {
                shape = flipShape(shape);
            }

            // íšŒì „
            for (let i = 0; i < piece.rotation; i++) {
                shape = rotateShape(shape);
            }

            return shape;
        }

        // ë³´ë“œ ë Œë”ë§
        function renderBoard() {
            const boardElement = document.getElementById('gameBoard');

            // ì²« ë Œë”ë§ì¸ì§€ í™•ì¸
            const isFirstRender = boardElement.children.length === 0;

            if (isFirstRender) {
                boardElement.innerHTML = '';

                // ì´ë²¤íŠ¸ ìœ„ì„: ë³´ë“œ ì „ì²´ì— í•œ ë²ˆë§Œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
                boardElement.addEventListener('click', (e) => {
                    const cell = e.target.closest('.cell');
                    if (cell) {
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        handleCellClick(row, col);
                    }
                });

                boardElement.addEventListener('mouseover', (e) => {
                    const cell = e.target.closest('.cell');
                    if (cell) {
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        showPreview(row, col);
                    }
                });
            }

            const currentPlayer = game.players[game.currentPlayerIndex];
            const isFirstPiece = currentPlayer && currentPlayer.pieces.every(p => !p.used);

            // ì…€ ì—…ë°ì´íŠ¸ (ì¬ìƒì„±í•˜ì§€ ì•Šê³  í´ë˜ìŠ¤ë§Œ ì—…ë°ì´íŠ¸)
            if (!isFirstRender) {
                for (let r = 0; r < 20; r++) {
                    for (let c = 0; c < 20; c++) {
                        const cell = boardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (!cell) continue;

                        // ê¸°ì¡´ í´ë˜ìŠ¤ ì´ˆê¸°í™”
                        cell.className = 'cell';

                        // ëª¨ì„œë¦¬ í‘œì‹œ
                        if ((r === 0 && c === 0) || (r === 0 && c === 19) ||
                            (r === 19 && c === 0) || (r === 19 && c === 19)) {
                            cell.classList.add('corner');
                        }

                        // í˜„ì¬ í”Œë ˆì´ì–´ì˜ ì‹œì‘ ëª¨ì„œë¦¬ ê°•ì¡°
                        if (isFirstPiece && !currentPlayer.isAI &&
                            r === currentPlayer.cornerY && c === currentPlayer.cornerX) {
                            cell.classList.add('start-corner');
                        }

                        // ë³´ë“œ ìƒíƒœ ë°˜ì˜
                        if (game.board[r][c]) {
                            cell.classList.add('filled', game.board[r][c]);
                        }
                    }
                }
            } else {
                // ì²« ë Œë”ë§: ì…€ ìƒì„±
                let cellCount = 0;
                for (let r = 0; r < 20; r++) {
                    for (let c = 0; c < 20; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;

                        // ëª¨ì„œë¦¬ í‘œì‹œ
                        if ((r === 0 && c === 0) || (r === 0 && c === 19) ||
                            (r === 19 && c === 0) || (r === 19 && c === 19)) {
                            cell.classList.add('corner');
                        }

                        // í˜„ì¬ í”Œë ˆì´ì–´ì˜ ì‹œì‘ ëª¨ì„œë¦¬ ê°•ì¡°
                        if (isFirstPiece && !currentPlayer.isAI &&
                            r === currentPlayer.cornerY && c === currentPlayer.cornerX) {
                            cell.classList.add('start-corner');
                        }

                        if (game.board[r][c]) {
                            cell.classList.add('filled', game.board[r][c]);
                        }

                        boardElement.appendChild(cell);
                        cellCount++;
                    }
                }
                console.log(`ë³´ë“œ ë Œë”ë§ ì™„ë£Œ: ${cellCount}ê°œ ì…€ ìƒì„±`);
            }
        }

        // í”Œë ˆì´ì–´ ì •ë³´ ë Œë”ë§
        function renderPlayersInfo() {
            const playersInfo = document.getElementById('playersInfo');
            playersInfo.innerHTML = '';

            game.players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = `player-info ${player.color}`;
                if (index === game.currentPlayerIndex) {
                    playerDiv.classList.add('active');
                }

                const usedPieces = player.pieces.filter(p => p.used).length;
                const totalSquares = player.pieces.reduce((sum, piece) => {
                    if (!piece.used) {
                        return sum + piece.shape.flat().filter(cell => cell === 1).length;
                    }
                    return sum;
                }, 0);

                playerDiv.innerHTML = `
                    <div class="name">${player.name}</div>
                    <div class="pieces-left">ì¡°ê°: ${21 - usedPieces}/21</div>
                    <div class="pieces-left">ë‚¨ì€ ì¹¸: ${totalSquares}</div>
                `;

                playersInfo.appendChild(playerDiv);
            });
        }

        // ì¡°ê° ë Œë”ë§ (í”Œë ˆì´ì–´ìš©)
        function renderPieces() {
            const currentPlayer = game.players[game.currentPlayerIndex];
            if (currentPlayer.isAI) return;

            const piecesGrid = document.getElementById('piecesGrid');
            piecesGrid.innerHTML = '';

            currentPlayer.pieces.forEach((piece, index) => {
                const pieceDiv = document.createElement('div');
                pieceDiv.className = 'piece';
                if (piece.used) {
                    pieceDiv.classList.add('used');
                }
                if (game.selectedPieceIndex === index) {
                    pieceDiv.classList.add('selected');
                }

                const shape = getCurrentShape(piece);
                const shapeDiv = document.createElement('div');
                shapeDiv.className = 'piece-shape';
                shapeDiv.style.gridTemplateColumns = `repeat(${shape[0].length}, 12px)`;
                shapeDiv.style.gridTemplateRows = `repeat(${shape.length}, 12px)`;

                shape.forEach(row => {
                    row.forEach(cell => {
                        const cellDiv = document.createElement('div');
                        cellDiv.className = 'piece-cell';
                        if (cell === 1) {
                            cellDiv.classList.add('filled', currentPlayer.color);
                        }
                        shapeDiv.appendChild(cellDiv);
                    });
                });

                pieceDiv.appendChild(shapeDiv);
                if (!piece.used) {
                    pieceDiv.addEventListener('click', () => selectPiece(index));
                }

                piecesGrid.appendChild(pieceDiv);
            });
        }

        // ì¡°ê° ì„ íƒ
        function selectPiece(index) {
            const currentPlayer = game.players[game.currentPlayerIndex];
            if (currentPlayer.pieces[index].used) {
                showDebug(`ì¡°ê° ${index}ëŠ” ì´ë¯¸ ì‚¬ìš©ë¨`);
                return;
            }

            game.selectedPieceIndex = index;
            showDebug(`âœ… ì¡°ê° ${index} ì„ íƒë¨! selectedPieceIndex = ${game.selectedPieceIndex}`);

            renderPieces();
            renderBoard();

            const isFirstPiece = currentPlayer.pieces.every(p => !p.used);
            if (isFirstPiece) {
                showMessage('âœ… ì¡°ê° ì„ íƒë¨! ì™¼ìª½ ìƒë‹¨ ëª¨ì„œë¦¬(â˜…)ë¥¼ ë®ë„ë¡ ë³´ë“œì— í´ë¦­í•˜ì„¸ìš”!');
            } else {
                showMessage('âœ… ì¡°ê° ì„ íƒë¨! ê°™ì€ ìƒ‰ì˜ ê¼­ì§€ì ì— ë‹¿ë„ë¡ ë°°ì¹˜í•˜ì„¸ìš”!');
            }
        }

        // ì¡°ê° ì„ íƒ ì·¨ì†Œ
        function deselectPiece() {
            game.selectedPieceIndex = null;

            // ë¯¸ë¦¬ë³´ê¸° ì œê±°
            lastPreviewCells.forEach(cell => {
                cell.classList.remove('preview', 'invalid-preview');
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);

                if (!game.board[r][c]) {
                    const currentPlayer = game.players[game.currentPlayerIndex];
                    const isFirstPiece = currentPlayer && currentPlayer.pieces.every(p => !p.used);

                    cell.className = 'cell';

                    if ((r === 0 && c === 0) || (r === 0 && c === 19) ||
                        (r === 19 && c === 0) || (r === 19 && c === 19)) {
                        cell.classList.add('corner');
                    }

                    if (isFirstPiece && !currentPlayer.isAI &&
                        r === currentPlayer.cornerY && c === currentPlayer.cornerX) {
                        cell.classList.add('start-corner');
                    }
                }
            });
            lastPreviewCells = [];

            renderPieces();
            renderBoard();
            showDebug('ì¡°ê° ì„ íƒ ì·¨ì†Œë¨');
            showMessage('ì¡°ê° ì„ íƒì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.');
        }

        // ì¡°ê° íšŒì „
        function rotatePiece() {
            if (game.selectedPieceIndex === null) return;

            const currentPlayer = game.players[game.currentPlayerIndex];
            const piece = currentPlayer.pieces[game.selectedPieceIndex];
            piece.rotation = (piece.rotation + 1) % 4;
            renderPieces();

            // ë¯¸ë¦¬ë³´ê¸° ì´ˆê¸°í™”
            lastPreviewCells.forEach(cell => {
                cell.classList.remove('preview', 'invalid-preview', 'filled', 'blue', 'yellow', 'red', 'green');
            });
            lastPreviewCells = [];

            showDebug('ì¡°ê° íšŒì „ë¨');
        }

        // ì¡°ê° ë’¤ì§‘ê¸°
        function flipPiece() {
            if (game.selectedPieceIndex === null) return;

            const currentPlayer = game.players[game.currentPlayerIndex];
            const piece = currentPlayer.pieces[game.selectedPieceIndex];
            piece.flipped = !piece.flipped;
            renderPieces();

            // ë¯¸ë¦¬ë³´ê¸° ì´ˆê¸°í™”
            lastPreviewCells.forEach(cell => {
                cell.classList.remove('preview', 'invalid-preview', 'filled', 'blue', 'yellow', 'red', 'green');
            });
            lastPreviewCells = [];

            showDebug('ì¡°ê° ë’¤ì§‘ê¸°ë¨');
        }

        // ë°°ì¹˜ ìœ íš¨ì„± ê²€ì‚¬
        function isValidPlacement(playerIndex, shape, row, col) {
            const player = game.players[playerIndex];
            const color = player.color;

            // ë³´ë“œ ë²”ìœ„ í™•ì¸
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c] === 1) {
                        const boardR = row + r;
                        const boardC = col + c;

                        if (boardR < 0 || boardR >= 20 || boardC < 0 || boardC >= 20) {
                            console.log(`ë²”ìœ„ ë²—ì–´ë‚¨: (${boardR}, ${boardC})`);
                            return false;
                        }

                        if (game.board[boardR][boardC] !== null) {
                            console.log(`ì´ë¯¸ ì°¨ìˆìŒ: (${boardR}, ${boardC}) = ${game.board[boardR][boardC]}`);
                            return false;
                        }
                    }
                }
            }

            // ì²« ë²ˆì§¸ ì¡°ê°ì¸ì§€ í™•ì¸
            const isFirstPiece = player.pieces.every(p => !p.used);

            if (isFirstPiece) {
                // ì²« ì¡°ê°ì€ ëª¨ì„œë¦¬ë¥¼ ë®ì–´ì•¼ í•¨
                let coversCorner = false;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[0].length; c++) {
                        if (shape[r][c] === 1) {
                            const boardR = row + r;
                            const boardC = col + c;
                            if (boardR === player.cornerY && boardC === player.cornerX) {
                                coversCorner = true;
                            }
                        }
                    }
                }
                console.log(`ì²« ì¡°ê° ëª¨ì„œë¦¬ ì²´í¬: ${coversCorner}, ëª©í‘œ: (${player.cornerY}, ${player.cornerX})`);
                return coversCorner;
            }

            // ê°™ì€ ìƒ‰ ì¡°ê°ê³¼ ë³€ìœ¼ë¡œ ì ‘ì´‰í•˜ëŠ”ì§€ í™•ì¸ (ë¶ˆê°€ëŠ¥)
            let touchesSameColorEdge = false;
            // ê°™ì€ ìƒ‰ ì¡°ê°ê³¼ ëª¨ì„œë¦¬ë¡œ ì ‘ì´‰í•˜ëŠ”ì§€ í™•ì¸ (í•„ìˆ˜)
            let touchesSameColorCorner = false;

            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c] === 1) {
                        const boardR = row + r;
                        const boardC = col + c;

                        // ë³€ ì²´í¬ (ìƒí•˜ì¢Œìš°)
                        const edges = [
                            [boardR - 1, boardC],
                            [boardR + 1, boardC],
                            [boardR, boardC - 1],
                            [boardR, boardC + 1]
                        ];

                        for (const [er, ec] of edges) {
                            if (er >= 0 && er < 20 && ec >= 0 && ec < 20) {
                                if (game.board[er][ec] === color) {
                                    touchesSameColorEdge = true;
                                }
                            }
                        }

                        // ëª¨ì„œë¦¬ ì²´í¬ (ëŒ€ê°ì„ )
                        const corners = [
                            [boardR - 1, boardC - 1],
                            [boardR - 1, boardC + 1],
                            [boardR + 1, boardC - 1],
                            [boardR + 1, boardC + 1]
                        ];

                        for (const [cr, cc] of corners) {
                            if (cr >= 0 && cr < 20 && cc >= 0 && cc < 20) {
                                if (game.board[cr][cc] === color) {
                                    touchesSameColorCorner = true;
                                }
                            }
                        }
                    }
                }
            }

            if (touchesSameColorEdge) {
                return false;
            }

            if (!touchesSameColorCorner) {
                return false;
            }

            return true;
        }

        // ì¡°ê° ë°°ì¹˜
        function placePiece(playerIndex, pieceIndex, row, col) {
            const player = game.players[playerIndex];
            const piece = player.pieces[pieceIndex];
            const shape = getCurrentShape(piece);

            if (!isValidPlacement(playerIndex, shape, row, col)) {
                return false;
            }

            // ë³´ë“œì— ë°°ì¹˜
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c] === 1) {
                        game.board[row + r][col + c] = player.color;
                    }
                }
            }

            piece.used = true;
            return true;
        }

        // ë¯¸ë¦¬ë³´ê¸° ìƒíƒœ ì €ì¥
        let lastPreviewCells = [];

        // ë¯¸ë¦¬ë³´ê¸°
        function showPreview(row, col) {
            // ì´ì „ ë¯¸ë¦¬ë³´ê¸° ì™„ì „íˆ ì œê±°
            lastPreviewCells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);

                // ì‹¤ì œë¡œ ë°°ì¹˜ëœ ì¡°ê°ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì œê±°
                if (!game.board[r][c]) {
                    const currentPlayer = game.players[game.currentPlayerIndex];
                    const isFirstPiece = currentPlayer && currentPlayer.pieces.every(p => !p.used);

                    // ëª¨ë“  í´ë˜ìŠ¤ ì œê±°í•˜ê³  ë‹¤ì‹œ ì„¤ì •
                    cell.className = 'cell';

                    if ((r === 0 && c === 0) || (r === 0 && c === 19) ||
                        (r === 19 && c === 0) || (r === 19 && c === 19)) {
                        cell.classList.add('corner');
                    }

                    if (isFirstPiece && !currentPlayer.isAI &&
                        r === currentPlayer.cornerY && c === currentPlayer.cornerX) {
                        cell.classList.add('start-corner');
                    }
                }
            });
            lastPreviewCells = [];

            if (game.selectedPieceIndex === null) return;

            const currentPlayer = game.players[game.currentPlayerIndex];
            if (currentPlayer.isAI) return;

            const piece = currentPlayer.pieces[game.selectedPieceIndex];
            const shape = getCurrentShape(piece);

            const valid = isValidPlacement(game.currentPlayerIndex, shape, row, col);

            // ìƒˆ ë¯¸ë¦¬ë³´ê¸° ì¶”ê°€
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c] === 1) {
                        const boardR = row + r;
                        const boardC = col + c;

                        if (boardR >= 0 && boardR < 20 && boardC >= 0 && boardC < 20) {
                            const cell = document.querySelector(`[data-row="${boardR}"][data-col="${boardC}"]`);
                            if (cell && !game.board[boardR][boardC]) {
                                cell.classList.add('filled', currentPlayer.color, 'preview');
                                if (!valid) {
                                    cell.classList.add('invalid-preview');
                                }
                                lastPreviewCells.push(cell);
                            }
                        }
                    }
                }
            }
        }

        // ì…€ í´ë¦­ ì²˜ë¦¬
        function handleCellClick(row, col) {
            showDebug(`ğŸ–±ï¸ ë³´ë“œ í´ë¦­: (${row}, ${col}), selectedPieceIndex = ${game.selectedPieceIndex}`);

            if (game.selectedPieceIndex === null) {
                showMessage('âš ï¸ ë¨¼ì € ì˜¤ë¥¸ìª½ì—ì„œ ì¡°ê°ì„ ì„ íƒí•´ì£¼ì„¸ìš”!');
                showDebug('âŒ ì¡°ê°ì´ ì„ íƒë˜ì§€ ì•ŠìŒ');
                return;
            }

            const currentPlayer = game.players[game.currentPlayerIndex];
            if (currentPlayer.isAI) {
                showDebug('âŒ AI í”Œë ˆì´ì–´ì˜ í„´');
                return;
            }

            const piece = currentPlayer.pieces[game.selectedPieceIndex];
            const shape = getCurrentShape(piece);
            const isFirstPiece = currentPlayer.pieces.every(p => !p.used);

            showDebug(`ì¡°ê° ì •ë³´: ì¸ë±ìŠ¤=${game.selectedPieceIndex}, ì²«ì¡°ê°=${isFirstPiece}, í¬ê¸°=${shape.length}x${shape[0].length}`);

            if (placePiece(game.currentPlayerIndex, game.selectedPieceIndex, row, col)) {
                showDebug('âœ… ë°°ì¹˜ ì„±ê³µ!');
                showMessage('âœ… ì¡°ê° ë°°ì¹˜ ì„±ê³µ!');
                game.selectedPieceIndex = null;
                game.passCount = 0;
                nextTurn();
            } else {
                showDebug('âŒ ë°°ì¹˜ ì‹¤íŒ¨');
                if (isFirstPiece) {
                    showMessage(`âŒ ì²« ì¡°ê°ì€ ì™¼ìª½ ìƒë‹¨ ëª¨ì„œë¦¬(â˜…)ë¥¼ ë®ì–´ì•¼ í•©ë‹ˆë‹¤!`);
                } else {
                    showMessage('âŒ ì¡°ê°ì€ ê°™ì€ ìƒ‰ ì¡°ê°ê³¼ ê¼­ì§€ì ìœ¼ë¡œë§Œ ë‹¿ì•„ì•¼ í•˜ê³ , ë³€ìœ¼ë¡œëŠ” ë‹¿ìœ¼ë©´ ì•ˆë©ë‹ˆë‹¤!');
                }
            }
        }

        // ë©”ì‹œì§€ í‘œì‹œ
        function showMessage(message) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
        }

        // ë””ë²„ê·¸ ì •ë³´ í‘œì‹œ
        function showDebug(message) {
            const debugBox = document.getElementById('debugInfo');
            const timestamp = new Date().toLocaleTimeString();
            debugBox.textContent = `[${timestamp}] ${message}`;
            console.log(`[ë””ë²„ê·¸] ${message}`);
        }

        // ë‹¤ìŒ í„´
        function nextTurn() {
            game.currentPlayerIndex = (game.currentPlayerIndex + 1) % 4;

            // ë¯¸ë¦¬ë³´ê¸° ì´ˆê¸°í™”
            lastPreviewCells.forEach(cell => {
                cell.classList.remove('preview', 'invalid-preview');
            });
            lastPreviewCells = [];

            renderBoard();
            renderPlayersInfo();
            renderPieces();

            const currentPlayer = game.players[game.currentPlayerIndex];
            showMessage(`${currentPlayer.name}ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤.`);
            showDebug(`í„´ ë³€ê²½: ${currentPlayer.name} (${currentPlayer.color})`);

            // AI í„´
            if (currentPlayer.isAI) {
                setTimeout(() => {
                    aiMove();
                }, 1000);
            }
        }

        // í„´ ë„˜ê¸°ê¸°
        function skipTurn() {
            const currentPlayer = game.players[game.currentPlayerIndex];
            currentPlayer.canPlay = false;
            game.passCount++;

            showMessage(`${currentPlayer.name}ì´(ê°€) í„´ì„ ë„˜ê²¼ìŠµë‹ˆë‹¤.`);

            if (game.passCount >= 4) {
                endGame();
                return;
            }

            nextTurn();
        }

        // AI ì´ë™ (ê³ ìˆ˜ ëª¨ë“œ)
        function aiMove() {
            const playerIndex = game.currentPlayerIndex;
            const player = game.players[playerIndex];

            let bestMove = null;
            let bestScore = -Infinity;

            // ëª¨ë“  ì‚¬ìš© ê°€ëŠ¥í•œ ì¡°ê°ì— ëŒ€í•´
            for (let pieceIndex = 0; pieceIndex < player.pieces.length; pieceIndex++) {
                const piece = player.pieces[pieceIndex];
                if (piece.used) continue;

                // ëª¨ë“  íšŒì „ê³¼ ë’¤ì§‘ê¸° ì‹œë„
                for (let rotation = 0; rotation < 4; rotation++) {
                    for (let flipped = 0; flipped < 2; flipped++) {
                        piece.rotation = rotation;
                        piece.flipped = flipped === 1;

                        const shape = getCurrentShape(piece);

                        // ë³´ë“œì˜ ëª¨ë“  ìœ„ì¹˜ ì‹œë„
                        for (let row = 0; row < 20; row++) {
                            for (let col = 0; col < 20; col++) {
                                if (isValidPlacement(playerIndex, shape, row, col)) {
                                    const score = evaluateMove(playerIndex, pieceIndex, shape, row, col);
                                    if (score > bestScore) {
                                        bestScore = score;
                                        bestMove = { pieceIndex, row, col, rotation, flipped: flipped === 1 };
                                    }
                                }
                            }
                        }
                    }
                }

                // ì›ë˜ ìƒíƒœë¡œ ë³µì›
                piece.rotation = 0;
                piece.flipped = false;
            }

            if (bestMove) {
                const piece = player.pieces[bestMove.pieceIndex];
                piece.rotation = bestMove.rotation;
                piece.flipped = bestMove.flipped;

                placePiece(playerIndex, bestMove.pieceIndex, bestMove.row, bestMove.col);
                game.passCount = 0;
                nextTurn();
            } else {
                skipTurn();
            }
        }

        // ì´ë™ í‰ê°€ (ê³ ìˆ˜ AI ì „ëµ)
        function evaluateMove(playerIndex, pieceIndex, shape, row, col) {
            let score = 0;
            const player = game.players[playerIndex];

            // 1. í° ì¡°ê°ì„ ìš°ì„  ë°°ì¹˜ (ì¡°ê° í¬ê¸°ì— ë¹„ë¡€)
            const pieceSize = shape.flat().filter(cell => cell === 1).length;
            score += pieceSize * 10;

            // 2. ë³´ë“œ ì¤‘ì•™ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ë†’ì€ ì ìˆ˜
            const centerDistance = Math.abs(row + shape.length / 2 - 10) +
                                  Math.abs(col + shape[0].length / 2 - 10);
            score -= centerDistance * 2;

            // 3. ìƒˆë¡œìš´ ì½”ë„ˆ ìƒì„± ê°œìˆ˜ (í™•ì¥ ê°€ëŠ¥ì„±)
            let newCorners = 0;
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c] === 1) {
                        const boardR = row + r;
                        const boardC = col + c;

                        // ëŒ€ê°ì„  ë°©í–¥ ì²´í¬
                        const corners = [
                            [boardR - 1, boardC - 1],
                            [boardR - 1, boardC + 1],
                            [boardR + 1, boardC - 1],
                            [boardR + 1, boardC + 1]
                        ];

                        for (const [cr, cc] of corners) {
                            if (cr >= 0 && cr < 20 && cc >= 0 && cc < 20 && game.board[cr][cc] === null) {
                                // í•´ë‹¹ ìœ„ì¹˜ê°€ ë³€ìœ¼ë¡œ ê°™ì€ ìƒ‰ê³¼ ì ‘ì´‰í•˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸
                                const edges = [
                                    [cr - 1, cc],
                                    [cr + 1, cc],
                                    [cr, cc - 1],
                                    [cr, cc + 1]
                                ];

                                let touchesEdge = false;
                                for (const [er, ec] of edges) {
                                    if (er >= 0 && er < 20 && ec >= 0 && ec < 20) {
                                        if (game.board[er][ec] === player.color) {
                                            touchesEdge = true;
                                        }
                                    }
                                }

                                if (!touchesEdge) {
                                    newCorners++;
                                }
                            }
                        }
                    }
                }
            }
            score += newCorners * 20;

            // 4. ìƒëŒ€ë°©ì˜ í™•ì¥ ë°©í•´
            let blocksOpponents = 0;
            const opponentColors = game.players
                .filter((_, idx) => idx !== playerIndex)
                .map(p => p.color);

            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c] === 1) {
                        const boardR = row + r;
                        const boardC = col + c;

                        // ì£¼ë³€ì— ìƒëŒ€ ì¡°ê°ì´ ìˆëŠ”ì§€ í™•ì¸
                        const corners = [
                            [boardR - 1, boardC - 1],
                            [boardR - 1, boardC + 1],
                            [boardR + 1, boardC - 1],
                            [boardR + 1, boardC + 1]
                        ];

                        for (const [cr, cc] of corners) {
                            if (cr >= 0 && cr < 20 && cc >= 0 && cc < 20) {
                                if (opponentColors.includes(game.board[cr][cc])) {
                                    blocksOpponents++;
                                }
                            }
                        }
                    }
                }
            }
            score += blocksOpponents * 5;

            // 5. ì²« ë²ˆì§¸ ì¡°ê°ì€ ì¤‘ì•™ ë°©í–¥ìœ¼ë¡œ
            const isFirstPiece = player.pieces.every(p => !p.used);
            if (isFirstPiece) {
                score += 50; // ì²« ì¡°ê° ë³´ë„ˆìŠ¤
            }

            return score;
        }

        // ê²Œì„ ì¢…ë£Œ
        function endGame() {
            const scores = game.players.map(player => {
                const remainingSquares = player.pieces.reduce((sum, piece) => {
                    if (!piece.used) {
                        return sum + piece.shape.flat().filter(cell => cell === 1).length;
                    }
                    return sum;
                }, 0);

                let score = -remainingSquares;

                // ëª¨ë“  ì¡°ê°ì„ ë†“ì•˜ëŠ”ì§€ í™•ì¸
                const allPiecesUsed = player.pieces.every(p => p.used);
                if (allPiecesUsed) {
                    score += 15;

                    // ë§ˆì§€ë§‰ ì¡°ê°ì´ 1ì¹¸ ì¡°ê°ì¸ì§€ í™•ì¸
                    const lastPiece = player.pieces[0]; // 1ì¹¸ ì¡°ê°ì€ ì²« ë²ˆì§¸
                    if (lastPiece.used) {
                        // ì‹¤ì œë¡œ ë§ˆì§€ë§‰ì— ë†“ì•˜ëŠ”ì§€ëŠ” ì¶”ì í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë³´ë„ˆìŠ¤ ì œê³µ
                        score += 5;
                    }
                }

                return { player, score };
            });

            scores.sort((a, b) => b.score - a.score);

            const finalScoresDiv = document.getElementById('finalScores');
            finalScoresDiv.innerHTML = scores.map((item, index) => {
                const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : '';
                return `
                    <div class="score-item ${item.player.color}">
                        ${medal} ${item.player.name}: ${item.score}ì 
                    </div>
                `;
            }).join('');

            document.getElementById('gameOver').classList.add('show');
        }

        // ê²Œì„ ë¦¬ì…‹
        function resetGame() {
            game.board = Array(20).fill(null).map(() => Array(20).fill(null));
            game.currentPlayerIndex = 0;
            game.selectedPieceIndex = null;
            game.passCount = 0;
            game.gameStarted = false;

            // ë¯¸ë¦¬ë³´ê¸° ì´ˆê¸°í™”
            lastPreviewCells = [];

            initializePieces();

            game.players.forEach(player => {
                player.canPlay = true;
            });

            document.getElementById('gameOver').classList.remove('show');

            // ë³´ë“œ ì™„ì „ ì¬ìƒì„±
            const boardElement = document.getElementById('gameBoard');
            boardElement.innerHTML = '';

            renderBoard();
            renderPlayersInfo();
            renderPieces();
            showMessage('ğŸ® ê²Œì„ ì‹œì‘! ì¡°ê°ì„ ì„ íƒí•˜ê³  ì™¼ìª½ ìƒë‹¨ ëª¨ì„œë¦¬(â˜…)ë¥¼ ë®ë„ë¡ ë°°ì¹˜í•˜ì„¸ìš”!');
            showDebug('ê²Œì„ ë¦¬ì…‹ ì™„ë£Œ');
        }

        // ê²Œì„ ì´ˆê¸°í™”
        function initGame() {
            console.log('ê²Œì„ ì´ˆê¸°í™” ì‹œì‘');
            initializePieces();
            renderBoard();
            renderPlayersInfo();
            renderPieces();
            showMessage('ğŸ® ê²Œì„ ì‹œì‘! ì¡°ê°ì„ ì„ íƒí•˜ê³  ì™¼ìª½ ìƒë‹¨ ëª¨ì„œë¦¬(â˜…)ë¥¼ ë®ë„ë¡ ë°°ì¹˜í•˜ì„¸ìš”!');
            showDebug('ê²Œì„ ì´ˆê¸°í™” ì™„ë£Œ. ì¡°ê°ì„ ì„ íƒí•˜ì„¸ìš”!');
            console.log('ì„ íƒëœ ì¡°ê° ì¸ë±ìŠ¤:', game.selectedPieceIndex);
            console.log('í˜„ì¬ í”Œë ˆì´ì–´ ì¸ë±ìŠ¤:', game.currentPlayerIndex);
        }

        // í…ŒìŠ¤íŠ¸ í•¨ìˆ˜
        function testClick() {
            const currentPlayer = game.players[game.currentPlayerIndex];
            const msg = `
í˜„ì¬ ìƒíƒœ:
- í”Œë ˆì´ì–´: ${currentPlayer.name} (${currentPlayer.color})
- ì„ íƒëœ ì¡°ê°: ${game.selectedPieceIndex === null ? 'ì—†ìŒ' : game.selectedPieceIndex}
- AI í„´: ${currentPlayer.isAI}
- ì‚¬ìš©í•œ ì¡°ê°: ${currentPlayer.pieces.filter(p => p.used).length}/21
            `.trim();
            alert(msg);
            showDebug(msg.replace(/\n/g, ' | '));
        }

        // ëª¨ë°”ì¼ í„°ì¹˜ ìµœì í™”
        function preventZoom(e) {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }

        // ë”ë¸” íƒ­ ì¤Œ ë°©ì§€
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (e) {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // í•€ì¹˜ ì¤Œ ë°©ì§€
        document.addEventListener('touchmove', preventZoom, { passive: false });

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ê²Œì„ ì‹œì‘
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
